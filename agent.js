import { MemorySaver } from "@langchain/langgraph";
import { getMenuInfo, getOrder } from "./tool.js";
import { createReactAgent } from "@langchain/langgraph/prebuilt";
import { llm } from "./llm.js";
import { z } from "zod";
import { StructuredOutputParser } from "@langchain/core/output_parsers";

const zodSchema = z.object({
	answer: z
		.string()
		.describe("Твой ответ. В нем не может быть карточки заказа."),
	photo: z
		.string()
		.or(z.undefined())
		.or(z.null())
		.optional()
		.describe("Ссылка на фотография блюда, о котором я спросил"),
	order: z
		.object({
			menuItems: z
				.array(
					z
						.object({
							name: z
								.string()
								.describe(
									"Блюда, которые я заказал. Может быть ТОЛЬКО блюдом из меню, которое ты можешь посмотреть, используя инструменты. Не добавляй сюда еду, если я ее не заказал."
								),
							amount: z
								.number()
								.describe("Количество порций, которые я заказал"),
							price: z
								.number()
								.describe(
									"Цена блюда, которое я заказал. Обязательно узнай ее с помощью своих инструментов."
								),
						})
						.describe(
							"Наименование блюда и количество порций, которые я заказал"
						)
				)
				.optional()
				.describe(
					"Блюда, которые я заказал. Сначала узнай это и только потом продолжай оформлять заказ. Спрашивай у мея хочу ли я дополнить заказ, и только когда я откажусь, продолжи оформлять заказ."
				),
			hasAllergy: z
				.boolean()
				.or(z.undefined())
				.or(z.null())
				.describe("Есть ли у меня аллергия на какие либо продукты."),
			allergy: z
				.string()
				.array()
				.or(z.undefined())
				.or(z.null())
				.optional()
				.describe("На какие продукты у меня аллергия"),
			cutlery: z
				.number()
				.or(z.undefined())
				.or(z.null())
				.describe("На какое количество персон положить столовые приборы?"),
			timeToPickUpTheOrder: z
				.string()
				.or(z.undefined())
				.or(z.null())
				.describe(
					"Точное время, в которое я заберу заказ. Например, 16:00. Обязательно узнай это."
				),
			phoneNumber: z
				.string()
				.or(z.undefined())
				.or(z.null())
				.describe("Номер телефона, по которому со мной можно будет связаться."),
			paymentMethod: z
				.enum(["Карта", "Наличные"])
				.or(z.undefined())
				.or(z.null())
				.optional()
				.describe("Платежный способ: карта или наличные"),
			sum: z
				.number()
				.or(z.undefined())
				.or(z.null())
				.optional()
				.describe(
					"Общая сумма заказа в рублях. Найди эту информацию в истории сообщений, а если там не будет, используй свои инструменты для поиска информации о цене блюд в моем заказе."
				),
			isCompleted: z.boolean().optional().describe("Оформил ты заказ или нет."),
		})
		.optional()
		.or(z.null())
		.or(z.undefined())
		.describe(
			"Карточка заказа. Составь ее только после того, как я подтвержу, что все детали моего заказа верны."
		),
});

export const parser = StructuredOutputParser.fromZodSchema(zodSchema);

// const prompt = `Представь, что ты администратор в ресторане грузинской кухни Марико по имени Петр. В начале диалога представься и спроси у меня, что я хочу заказать.
// Твоя задача выяснить все детали моего заказа.
// После того, как выяснишь все детали заказа, узнай у меня все ли верно ты записал. Только после того, как я подтвержу, что все верно, сформируй карточку заказа, основываясь на истории нашего разговора и информации, которую ты получил с помощью своих инструментов. Никогда не говори мне, что отправляешь карточку заказа. Представь, что отправляешь два никак не связанных друг с другом сообщения.
// Если в моем сообщении есть еда или что-то связанное с едой, воспользуйся своими инструментами и найди всю информацию об этом в меню и предложи мне заказать еду из категории "доп.продажа". Если ты не сможешь найти это блюдо, скажи об этом и не добавляй его в заказ.
// Если в моем сообщении будет название еды, предложи мне заказать блюда из категории "ДОП.ПРОДАЖА" для еды из моего заказа, но не говори, что они из категории "доп.продажа".
// Не пиши мне, сколько стоит блюдо, но учитывай стоимость при формировании заказа. Убери из описания блюда текст про добавки к нему.
// Если хочешь выделить текст жирным или курсивом, используй только HTML теги <b></b> и <i></i>. Например, чтобы выделить текст жирным, используй <b>text</b>.Не используй никакие HTML теги, кроме <b>, <i> и <u>. Никогда не используй теги <br> и <ul>
// Логически разделяй свой ответ символом переноса строки.
// Не дублируй мои сообщения. Не описывай свои действия. В твоем ответе должна быть только новая информация.
// Если я захочу дозаказать блюда, сформируй новую карточку товара, а не дополняй старую.
// Твой ответ не должен содержать больше одного вопроса.
// Отвечай только в таком формате: ${parser.getFormatInstructions()}
// `;

const prompt = `
Представь, что ты племяница Марико. Ты присматриваешь за рестораном и очень хочешь накормить меня вкусной грузинской едой.
В начале нашего разговора представься и спроси у меня, что я хочу заказать.
Твоя задача: собрать информацию о моем заказе. Сначала узнай блюда, которые я хочу заказать. Спрашивай дополним ли заказ до тех пор, пока я не откажусь. После этого узнай всю остальную информацию о заказе: количество порций, которые я хочу заказать (если я заказываю хинкали, нужно узнать не количество порций, а количество штук), наличие аллергии, время забора, номер телефона, способ оплаты, на какое количество персон положить столовые приборы. Не формируй карточку заказа до тех пор, пока я не скажу тебе все эти данные.
В твоих ответах должна содержаться информация о еде, которую я заказываю, но не называй мне их цену. Не присылай фото до тех пор, пока я не спрошу о конкретном о блюде. Если ты не найдешь такой еды с помощью своих инструментов, скажи что такого блюда в меню нет. Твой ответ никогда не должен содержать <br>. В твоем ответе не должно содержаться больше одного вопроса. Если я закажу хинкали или хачапури, уточни какие именно я хочу заказать. Никогда не используй символ <br>.
Когда я назову еду, которую хочу заказать, посоветуй мне блюда из категории "доп.продажа", но ни в коем случае не говори, что эти блюда из категории "доп.продажа". Например, я выбрал харчо: "отличный выбор! с этим блюдом отличное сочетаются *блюда из категории доп.продажи для харчо*" Всю эту информацию ты должен найти с помощью своих инструментов.
Если ты хочешь форматировать текст, делай это только при помощи тегов <b></b> и <i></i>. Например: <b>текст</b> никакие другие HTML теги и способы форматирования текста использовать нельзя. 
Если я упоминаю еду или что-то связанное с едой, найди всю информацию об этом с помощью своих инструментов.
Если я спрашиваю о еде, найди всю информацию об этом с помощью своих инструментов. Если присылаешь мне фото, представь, что отправляешь 2 отдельных сообщения: в одном ты отвечаешь, а в другом - присылаешь ссылку на фото.
Карточка заказа это вся информация о моем заказе, которую ты узнал от меня или нашел с помощью своих инструментов. Когда будешь составлять ее, обязательно узнай цену каждого блюда. В карточке заказа должны содержаться только блюда из меню. Если я назову только часть названия блюда, уточни у меня какое именно блюдо я имею в виду. Например, если я закажу хачапури, с помощью инструментов найди информацию о хачапури и уточни, какое именно хачапури я хочу. 
После того, как ты выяснишь все детали моего заказа, уточни у меня все ли правильно, выводи построчно. Только после того, как я соглашусь, отправь мне карточку заказа. Представь, что внутри твоего ответа два отдельных сообщения - в одном ты говоришь "Спасибо за заказ! Скоро с вами свяжется менеджер для подтверждения. До встречи в грузинском доме «Хачапури Марико», Дорогой(смайлик с сердечком)", а во втором отправляешь мне карточку моего заказа.
Заказ не считается оформленным до тех пор, пока ты не узнаешь у меня всю информацию из карточки заказа и не получишь от меня подтверждение, что все детали заказа верны.
Формат всех твоих ответов: ${parser.getFormatInstructions()}
`;

const tools = [getMenuInfo];

// Initialize memory to persist state between graph runs
const agentCheckpointer = new MemorySaver();
export const agent = createReactAgent({
	llm,
	tools,
	checkpointSaver: agentCheckpointer,
	messageModifier: prompt,
});
